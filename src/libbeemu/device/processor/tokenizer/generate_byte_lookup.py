# Generate byte length lookup table.
from datetime import datetime


# 16 bit long instructions
octetLongInstructions = [
    0x10,
    0x20,
    0x30,
    0x06,
    0x16,
    0x26,
    0x36,
    0x18,
    0x28,
    0x38,
    0x0E,
    0x1E,
    0x2E,
    0x3E,
    0xE0,
    0xF0,
    0xC6,
    0xD6,
    0xE6,
    0xF6,
    0xE8,
    0xF8,
    0xCE,
    0xDE,
    0xEE,
    0xFE,
]

# 24 bit long instructions
swordLongInstructions = [
    0x01,
    0x11,
    0x21,
    0x31,
    0x08,
    0xC2,
    0xD2,
    0xC3,
    0xC4,
    0xD4,
    0xCA,
    0xDA,
    0xEA,
    0xFA,
    0xCC,
    0xDC,
    0xCD,
]

# Combine the above arrays.
nonByteLongLookup = {
    **{opcode: 2 for opcode in octetLongInstructions},
    **{opcode: 3 for opcode in swordLongInstructions},
}


# Seperate lookup to two parts, this is because [0x40, 0xC0) range is always 1
# and we can safely ignore it.
pre0x40Lookup = [
    "1" if opcode not in nonByteLongLookup else f"{nonByteLongLookup[opcode]}"
    for opcode in range(0, 0x40)
]
post0xBFLookup = [
    "1" if opcode not in nonByteLongLookup else f"{nonByteLongLookup[opcode]}"
    for opcode in range(0xC0, 0x100)
]

with open("./bytewidth_lookup_table.gen.h", "w") as file:
    file.write(
        f"""
/**
 * @file bytewidth_lookup_table.gen.h
 * @author Ege Ã–zkan (elsaambertide@gmail.com)
 * @brief Private header file autogenerated with generate_byte_lookup.py
 * in the same source directory.
 * @version 0.1
 * @date {datetime.now():%Y-%m-%d}
 *
 * @copyright Copyright (c) {datetime.now():%Y}
 *
 */

#ifndef BEEMU_TOKENIZER_BYTEWIDTH_LOOKUP_TABLE_GEN_H
#define BEEMU_TOKENIZER_BYTEWIDTH_LOOKUP_TABLE_GEN_H
#include <stdint.h>
#ifdef __cplusplus
extern "C"
{{
#endif

\tconst uint8_t PRE_0X40_BYTE_LENGTH_LOOKUP[] = {{{', '.join(pre0x40Lookup)}}};
\tconst uint8_t POST_0XBF_BYTE_LENGTH_LOOKUP[] = {{{', '.join(post0xBFLookup)}}};

#ifdef __cplusplus
}}
#endif

#endif // BEEMU_TOKENIZER_BYTEWIDTH_LOOKUP_TABLE_GEN_H
"""
    )
